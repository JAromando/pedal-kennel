Layout:
File + Path
``````````````````````
Prompt
``````````````````````
Feedback
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_for_composition_code_average_problem\submissions\Fearow_1.py
``````````````````````
from bakery import assert_equal

def summate(values: [int]) -> int:
    total = 0
    for value in values:
        total = total + value
    return total

def count(values: [int]) -> int:
    total = 0
    for value in values:
        total = total + 1
    return total

def average(avg: list[int]) -> int:
    summate + count


``````````````````````
The 'average' function is missing a return statement.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_for_composition_code_average_problem\submissions\Ferrothorn_1.py
``````````````````````
#from bakery import assert_equal

def summate(values: [int]) -> int:
    total = 0
    for value in values:
        total = total + value
    return total

def count(values: [int]) -> int:
    total = 0
    for value in values:
        total = total + 1
    return total

def average(inList:list[int])-> int:
    total = 0 
    average = (summate(total) + count(total))
        
    return summate(inList)/count(inList)

``````````````````````
The 'average' function is not implemented correctly. You should calculate the sum and count separately before calculating the average.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_for_composition_code_average_problem\submissions\Petilil_1.py
``````````````````````
from bakery import assert_equal

def summate(values: [int]) -> int:
    total = 0
    for value in values:
        total = total + value
    return total

def count(values: [int]) -> int:
    total = 0
    for value in values:
        total = total + 1
    return total
def average (numbers:list)-> float:
    if numbers == []:
        return None
    _average = summate(numbers)/count(numbers)
    return _average
assert_equal(average([1, 2, 1]), 1.333333333333333)
assert_equal(average([]), None)



``````````````````````
The code looks good and it passes the provided test cases.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_for_loops_code_to_your_credit\submissions\Hoothoot_1.py
``````````````````````
courses = [3,3,3,3]
for a_course in courses:
    print (courses)

``````````````````````
You are printing the entire 'courses' list for each iteration of the loop. Did you mean to print the current course instead?
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_for_loops_code_to_your_credit\submissions\Pidgeot_1.py
``````````````````````
course_worth = [3, 4, 4, 3, 4]
for credits in course_worth:
    print(credits)
``````````````````````
Your code looks good!
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_for_patterns2_code_find_fruits\submissions\Bergmite_1.py
``````````````````````
from bakery import assert_equal

def find_fruit(foods: list[str]) -> str:
    result = "Missing"
    if not foods:
        return "fruitless"
    for food in foods:
        if food == "apple" or food == "orange" or food == "banana":
            result = food
        else:
            return "fruitless"
        return result

assert_equal(find_fruit(["banana","orange","apple"]), "apple")
assert_equal(find_fruit(["orange","orange","banana"]), "banana")
assert_equal(find_fruit(["banana","apple","orange"]), "orange")
assert_equal(find_fruit([]), "fruitless")

    
``````````````````````
The code has a logical error. The return statement inside the for loop is indented incorrectly. It should be outside the loop.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_for_patterns2_code_find_fruits\submissions\Tranquill_1.py
``````````````````````
from bakery import assert_equal

def find_fruit(fruits: list[str]) -> str:
    found = "fruitless"
    for fruit in fruits:
        if fruit[-1] == "e":
            found = fruit
        return found

assert_equal(find_fruit(["apple", "banana", "orange"]), "orange")
assert_equal(find_fruit(["banana", "orange", "apple"]), "apple")
assert_equal(find_fruit(["orange", "apple", "banana"]), "banana")
``````````````````````
The function returns 'fruitless' for all inputs. Make sure the return statement is properly indented.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_for_patterns2_code_find_fruits\submissions\Tranquill_2.py
``````````````````````
from bakery import assert_equal

def find_fruit(fruits: list[str]) -> str:
    found = "fruitless"
    for fruit in fruits:
        if fruit[-1] == "e" or "a":
            found = fruit
        return found

assert_equal(find_fruit(["apple", "banana", "orange"]), "orange")
``````````````````````
The return statement is indented inside the for loop. It should be outside the loop.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_for_patterns2_code_take\submissions\Aurorus_1.py
``````````````````````
from bakery import assert_equal
def until_period(words:list[str])->list[str]:
    newords=[]
    take=True
    for word in words:
        if '.' in word:
            take=False
            return take
        else:
            newords=newords.append(word)
            return newords
assert_equal(until_period(['a','.','b']),['a'])
``````````````````````
The function should return a list of words until the first period is encountered. You are returning a boolean value instead.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_for_patterns2_code_take\submissions\Reshiram_1.py
``````````````````````
from bakery import assert_equal
def until_period(examples: list[str]) -> list[str]:
    taking = False
    first_examples = []
    for example in examples:
        if example == ".":
            taking = True
        elif taking:
            first_examples.append(example)
        return examples
assert_equal(until_period(["Oh", "Hello", "There."]), ["Oh", "Hello", "There."])
assert_equal(until_period(["Kind", "Heart", "Money."]), ["Kind", "Heart", "Money."])
assert_equal(until_period(["Money", "Water", "Food"]), ["Money", "Water", "Food"])
assert_equal(until_period(
``````````````````````
The 'return' statement is inside the 'for' loop. It should be outside the loop to return the correct result.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_for_patterns2_code_take\submissions\Torkoal_1.py
``````````````````````
from bakery import assert_equal

def until_period(removeDot:list)->list:
    new_list = []
    for items in removeDot:
        if items == ".":
            new_list = removeDot
            new_list.remove(".")
            return new_list
assert_equal(until_period(["One", "Two", "."]), ["One", "Two"])
assert_equal(until_period(["One", "Two", "Three]), ["One", "Two","Three"])
``````````````````````
The code has a syntax error. You are missing a closing quotation mark in the second test case.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_functions_builtins_code_mystery_name\submissions\Dustox_1.py
``````````````````````
message = '"Why are you shouting?".uppercase()'.format(" ")
a_message = message.upper()
print(a_message)
``````````````````````
The method `.format()` is not needed in this case. Also, the method `.uppercase()` does not exist in Python. The correct method is `.upper()`.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_functions_builtins_code_mystery_name\submissions\Pansear_1.py
``````````````````````
message = "Why are you shouting?"

print(message.title())
``````````````````````
The 'title()' method is used to capitalize the first letter of each word in a string. However, it seems like you want to convert the entire string to uppercase. In that case, you can use the 'upper()' method instead.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_functions_builtins_code_mystery_name\submissions\Raikou_1.py
``````````````````````
message = "Why are you shouting?"

print(message.capitalize())
``````````````````````
The capitalize() method capitalizes the first letter of a string. However, it does not change the case of the remaining letters. If you want to capitalize all the letters in the string, you can use the upper() method instead.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_functions_calling_code_composed_calls\submissions\Dodrio_1.py
``````````````````````
price = round(float("9.5"))
print(price)
``````````````````````
The round() function rounds a number to the nearest integer. However, the float() function is unnecessary in this case because the argument '9.5' is already a float. You can directly use round(9.5) to get the rounded value.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_functions_calling_code_composed_calls\submissions\Magnemite_1.py
``````````````````````
floatNum = float(("9.5"))
roundedNum = round(floatNum)
print(roundedNum)

``````````````````````
The code is almost correct. However, there is a small mistake in the float() function call. The float() function takes a string or a number as an argument, but you have passed a tuple instead. To fix this, remove the parentheses around '9.5'.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_functions_calling_code_composed_calls\submissions\Omastar_1.py
``````````````````````
price = round(9.5)
print(float(price))

``````````````````````
The round() function rounds a number to the nearest integer. In this case, it rounds 9.5 to 10. However, the float() function is unnecessary because the result of round() is already a float.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_functions_docstrings_code_new_docs\submissions\Dewgong_1.py
``````````````````````
from cisc108 import assert_equal

def is_expected_user(name: str, age: int, height: float) -> bool:
       '''
        This function prints out the name, age, and height

        Args:
            name (str): The 
            age (int): how old the person is
            height (float): how tall the person is
        Returns:
            str: returns the name, age, and height
       '''
    return name == "Ada" and age == 1 and height == 11.7

assert_equal(is_expected_user("Ada", 1, 11.7), True)
assert_equal(is_expected_user("Pumpkin", 4, 9.8), False)
``````````````````````
The function is_expected_user() is missing an indentation.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_functions_docstrings_code_new_docs\submissions\Golett_1.py
``````````````````````
from cisc108 import assert_equal

def is_expected_user(name: str, age: int, height: float) -> bool:
    return name == "Ada" and age == 1 and height == 11.7
"""
    The function will take the inputted name, age, and height, and test
    to see if it is true or false
    
    Args:
        name(str): the name should be equal to whatever we want
        age(int): Whatever age we want to input
        height(float): whatever value we want as the height
    Returns: 
    boolean: whether or not the values in the test are equal to what is supposed to be returned. 
   
        """
assert_equal(is_expected_user("Ada", 1, 11.7), True)
assert_equal(is_expected_user("Pumpkin", 4, 9.8), False)
``````````````````````
The function is_expected_user() looks correct and the test cases are passing. Well done!
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_functions_docstrings_code_new_docs\submissions\Reshiram_1.py
``````````````````````
from bakery import assert_equal
# assert_equal is imported from bakery
def is_expected_user(name: str, age: int, height: float) -> bool:
    return name == "Ada" and age == 1 and height == 11.7
''' 
This function gives the name, age, and height of a user and determines whether or
not it is true.

Args:
    name (str): The name of the user
    age (int): The age of the user
    height (float): The height of the user
Returns:
    bool: Whether or not the information is true
    '''
assert_equal(is_expected_user("Ada", 1, 11.7), True)
assert_equal(is_expected_user("Pumpkin", 4, 9.8), False)
``````````````````````
The code looks good and the function is_expected_user() is correctly implemented.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_functions_scopes_code_weekend_off\submissions\Magnemite_1.py
``````````````````````
from cisc108 import assert_equal

def cut_day(day_of_week):
    return day_of_week[:-3]

assert_equal(cut_day("Wednesday"), "Wednes")
assert_equal(cut_day("Thursday"), "Thurs")
assert_equal(cut_day("Saturday"), "Satur")
``````````````````````
The code looks good and the assertions are passing.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_functions_scopes_code_weekend_off\submissions\Pidgeot_1.py
``````````````````````
from bakery import assert_equal

day_of_week = "Wednesday"
def cut_day(day_of_week:str= "Wednesday" or "Thursday" or "Saturday")->str:
    return day_of_week[:-3]

assert_equal(cut_day(day_of_week = "Wednesday"), "Wednes")
assert_equal(cut_day(day_of_week = "Thursday"), "Thurs")
assert_equal(cut_day(day_of_week = "Saturday"), "Satur")
``````````````````````
The function `cut_day` is correctly defined and the test cases are passing.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_functions_scopes_code_weekend_off\submissions\Torkoal_1.py
``````````````````````
from bakery import assert_equal

day_of_week = "Wednesday"

def cut_day():
    return day_of_week[:-3]

assert_equal(cut_day(), "Wednes")
assert_equal(cut_day(), "Thurs")
assert_equal(cut_day(), "Satur")
``````````````````````
The cut_day function is returning the first three letters of the day_of_week variable. However, the assert_equal calls are expecting different results. Make sure to update the assert_equal calls to match the expected results.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_if_patterns_dispatch_math\submissions\Lanturn_1.py
``````````````````````
from bakery import assert_equal

def dispatch_math(operator: str, a : int, b : int) -> int:
    if '+-/*' not in operator:
        return 0
    if operator == '/' and b == 0:
        return 0
    return (a + operator + b) 
    
assert_equal(dispatch_math('&', 1, 0), 0)
assert_equal(dispatch_math('*', 1, 0), 0)
assert_equal(dispatch_math('/', 2, 2), 1)
``````````````````````
The condition in line 3 is incorrect. You should check if the operator is not in '+-/*' instead of checking if '+-/*' is not in the operator.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_if_patterns_dispatch_math\submissions\Pansear_1.py
``````````````````````
from cisc108 import assert_equal
def dispatch_math(operator,num1,num2): # Function declaration
    if operator == '+': # if plus operator given then add num1 and num2
        return num1+num2
    elif operator == '-': # if minus operator given then subtract num1 and num2
        return num1-num2
    elif operator == '*': # if multiply operator given then multiply num1 by num2
        return num1*num2
    elif operator == '/': # if divide operator given then divide num1 by num2
        return num1/num2
    else:                 # else other operator given then return 0
        return 0
a = 5
b = 5
# Function call
print ("a + b = ",dispatch_math('+',a,b))
print ("a - b = ",dispatch_math('-',a,b))
print ("a * b = ",dispatch_math('*',a,b))
print ("a / b = ",dispatch_math('/',a,b))
print ("Anything else = ",dispatch_math('a',a,b))
``````````````````````
Great job on implementing the dispatch_math function! It correctly handles the four basic arithmetic operations. However, there is a small issue with the last print statement. Can you spot it?
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_if_patterns_dispatch_math\submissions\Quilladin_1.py
``````````````````````
from bakery import assert_equal


def dispatch_math(word:str, one:int, two:int,) -> str:
    if word == "+":
        return one + two
    if word == "-":
        return one - two
    if word == "*":
        return one * two
    if word == "/":
        return 0
    
assert_equal(dispatch_math("+", 2, 3), 5)
assert_equal(dispatch_math("-", 2, 3), -1)
assert_equal(dispatch_math("*", 2, 3), 6)
assert_equal(dispatch_math("/", 2, 3), 0)

``````````````````````
The code looks good and the tests pass!
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_if_syntax_code_rainy_days\submissions\Skiploom_1.py
``````````````````````
precipitation = 5

if precipitation > 50:
    print("It will probably rain.")
else:
    print("It might not rain.")
     

# ...
``````````````````````
The code looks correct and will correctly determine if it will rain or not based on the precipitation value.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_if_syntax_code_rainy_days\submissions\Snivy_1.py
``````````````````````
precipitation = .2
if precipitation > 0.5
    print("It will probably rain.")
else precipitation < 0.5
    print("It might not rain.")

# ...
``````````````````````
There are a couple of issues with your code:
1. You are missing a colon (:) after the if statement.
2. The else statement should not have a condition.

Here's the corrected code:

precipitation = 0.2
if precipitation > 0.5:
    print("It will probably rain.")
else:
    print("It might not rain.")
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_if_syntax_code_rainy_days\submissions\Voltorb_1.py
``````````````````````
precipitation = 0.1

if precipitation > 0.5:
    print("It will probably rain.")
else:
    print("It might not rain.")
``````````````````````
Your code looks good!
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_intro_errors_code_syntax\submissions\Gastly_1.py
``````````````````````
print("Hello World")

``````````````````````
Great job! You successfully printed 'Hello World'.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_intro_errors_code_syntax\submissions\Nidorano_1.py
``````````````````````
 print("Hello World")

``````````````````````
Great job! You have successfully printed 'Hello World'.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_intro_errors_code_syntax\submissions\Whiscash_1.py
``````````````````````
print("Hello World")

``````````````````````
Great job! You have successfully printed 'Hello World'.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_intro_eval_code_quick_calc\submissions\Aromatisse_1.py
``````````````````````
2+3
print(4+5)
``````````````````````
Good job! The first line correctly adds 2 and 3. However, the second line is missing the 'print' statement. Add 'print' before the expression to display the result.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_intro_eval_code_quick_calc\submissions\Elgyem_1.py
``````````````````````
2+3
print(4+5)
``````````````````````
You can directly execute the code without using the print statement.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_intro_eval_code_quick_calc\submissions\Mime Jr_1.py
``````````````````````

print(2+3)
``````````````````````
Great job! The code will print the sum of 2 and 3, which is 5.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_intro_logic_code_print_logic\submissions\Golett_1.py
``````````````````````
print(8>7)

``````````````````````
The code is correct.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_intro_logic_code_print_logic\submissions\Liepard_1.py
``````````````````````
print(8 > 7)
print(60 < 100 and 60 < 50)
print(2022 == 2015)
``````````````````````
The first print statement correctly compares if 8 is greater than 7 and prints True. 

The second print statement incorrectly uses the 'and' operator to compare if 60 is less than 100 and 60 is less than 50. This will always be False because 60 cannot be less than both 100 and 50 at the same time. 

The third print statement correctly compares if 2022 is equal to 2015 and prints False.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_intro_logic_code_print_logic\submissions\Swampert_1.py
``````````````````````
print(8>7)
print(60<100, 60<50)
print(2022-=2015)
``````````````````````
The first two print statements are correct. However, there is a syntax error in the third print statement. The -= operator is not valid for assignment. Did you mean to use the -= operator for subtraction?
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_intro_strings_code_double_quotes\submissions\Blitzle_1.py
``````````````````````
print("The dog's house is big and red.")

``````````````````````
Your code looks fine! It successfully prints the string 'The dog's house is big and red.'
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_intro_strings_code_double_quotes\submissions\Forretress_1.py
``````````````````````
print("The dog's house is big and red.")

``````````````````````
Your code looks fine! It will print the sentence 'The dog's house is big and red.'
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_intro_strings_code_double_quotes\submissions\Hoothoot_1.py
``````````````````````
print("the dog's house is big and red.")

``````````````````````
Your code is correct!
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_nesting_heavy_code_rainy_cloudy\submissions\Baltoy_1.py
``````````````````````
from dataclasses import dataclass
from bakery import assert_equal

@dataclass
class WeatherOptions:
    raining: bool
    cloudy: bool
    snowing: bool  

@dataclass
class Measurement:
    amount: int
    automatic: bool
    
@dataclass
class Report:
    temperature: int
    rainfall: list[Measurement]
    weather: WeatherOptions

@dataclass
class Forecast:
    when: str
    where: str
    reports: list[Report]
    
def rainiest_cloudy(forecasts: list[Forecast]) -> bool:
    rainfall = False
    max_rain = 0
    for forecast in forecasts:
        reportlist = forecast.reports
        for report in reportlist:
            rainlist = report.rainfall
            for rain in rainlist:
                if rain.amount > max_rain:
                    max_rain = rain.amount
                    max_day = report
    if report.weather.cloudy:
        rainfall = True
    return rainfall            



today = Forecast("today", "Newark, DE", [
    Report(54, [Measurement(1, True), Measurement(2, True)],
        WeatherOptions(True, True, False)),
    Report(65, [Measurement(2, True)],
        WeatherOptions(True, True, False)),
    Report(45, [],
        WeatherOptions(False, True, False))
])
tomorrow = Forecast("tomorrow", "Newark, DE", [
    Report(54, [Measurement(1, True), Measurement(1, True)],
        WeatherOptions(True, True, False)),
    Report(65, [Measurement(3, True), Measurement(5, True), Measurement(10, False)],
        WeatherOptions(True, True, True)),
    Report(45, [Measurement(20, True)],
        WeatherOptions(True, False, False))
])

soon = Forecast("soon", "Newark, DE", [
    Report(14, [Measurement(5, False)],
        WeatherOptions(False, True, True))
])

assert_equal([today, tomorrow], 0)
assert_equal([soon], 0)

    

``````````````````````
The code seems to be missing the necessary imports for the `assert_equal` function and the `bakery` module. You should import them at the beginning of your code.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_nesting_heavy_code_rainy_cloudy\submissions\Girafarig_1.py
``````````````````````
from dataclasses import dataclass
from bakery import assert_equal

@dataclass
class WeatherOptions:
    raining: bool
    cloudy: bool
    snowing: bool

@dataclass
class Measurement:
    amount: int
    automatic: bool

@dataclass
class Report:
    temperature: int
    rainfall: list[Measurement]
    weather: WeatherOptions

@dataclass
class Forecast:
    when: str
    where: str
    reports: list[Report]

def get_reports(forecasts: list[Forecast]) -> list[Report]:
    reports = []
    for forecast in forecasts:
        for report in forecast.reports:
            reports.append(report)
    return reports
    
def rainiest_cloudy(forecasts: list[Forecast]) -> bool:
    reports = get_reports(forecasts)
    if not forecasts:
        return False
    max_rainfall = reports[0].rainfall[0].amount
    most_rainy_report = reports[0]
    for report in reports:
        print(type(report))
        for measurement in report.rainfall:
            if measurement.amount > max_rainfall:
                max_rainfall = measurement.amount
                most_rainy_report = report
    return most_rainy_report.weather.cloudy

reports1 = [Report(52, [Measurement(2, True)], WeatherOptions(True, True, False))]
forecast1 = Forecast('Here', '12:00', reports1)
forecasts1 = [forecast1]

assert_equal(rainiest_cloudy([forecast1]), True)
``````````````````````
The code looks good and runs without any errors.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_nesting_heavy_code_rainy_cloudy\submissions\Uxie_1.py
``````````````````````
from dataclasses import dataclass 
from bakery import assert_equal 

@dataclass
class Measurement: 
    amount: int
    automatic: bool 

@dataclass
class WeatherOptions: 
    raining: bool 
    cloudy: bool 
    snowing: bool 
    
@dataclass
class Report: 
    temperature: int
    rainfall: list[Measurement]
    weather: WeatherOptions
      
@dataclass 
class Forecast: 
    when: str
    where: str
    reports: list[Report]
    
forecasts = [Forecast("Night", "Delaware", [Report(54, [Measurement(2, True), Measurement(1, False)], WeatherOptions(True, True, False))]),
            Forecast("Day", "New York", [Report(32, [Measurement(0, True), Measurement(1, True)], WeatherOptions(False, True, True))])] 

forecasts_2 = [Forecast("Night", "Delaware", [Report(54, [Measurement(6, True), Measurement(4, False)], WeatherOptions(True, True, False))]),
            Forecast("Day", "New York", [Report(32, [Measurement(3, True), Measurement(2, True)], WeatherOptions(True, True, False))])] 

today = Forecast("today", "Newark, DE", [
    Report(54, [Measurement(1, True), Measurement(2, True)],
        WeatherOptions(True, True, False)),
    Report(65, [Measurement(2, True)],
        WeatherOptions(True, True, False)),
    Report(45, [],
        WeatherOptions(False, True, False))
])

tomorrow = Forecast("tomorrow", "Newark, DE", [
    Report(54, [Measurement(1, True), Measurement(1, True)],
        WeatherOptions(True, True, False)),
    Report(65, [Measurement(3, True), Measurement(5, True), Measurement(10, False)],
        WeatherOptions(True, True, True)),
    Report(45, [Measurement(20, True)],
        WeatherOptions(True, False, False))
])

soon = Forecast("soon", "Newark, DE", [
    Report(14, [Measurement(5, False)],
        WeatherOptions(False, True, True))
])

empty = Forecast("empty", "Newark, DE", [] )   
    
def rainiest_cloudy (forecasts: list[Forecast]) -> bool:
    max_rain = 0
    is_cloudy = False
    for forecast in forecasts:
        for report in forecast.reports:
            if report.weather.cloudy == True:
                for rainfall in report.rainfall:
                    if rainfall.amount > max_rain:
                        max_rain = rainfall.amount
                        is_cloudy = True
            else:
                is_cloudy = False
    return is_cloudy
                    

assert_equal(rainiest_cloudy([empty, empty]), False)
assert_equal(rainiest_cloudy([today]), True)
assert_equal(rainiest_cloudy([tomorrow]), False)



           
           
        
``````````````````````
Great job on implementing the `rainiest_cloudy` function! It correctly checks if a forecast has the highest amount of rainfall when it is cloudy. However, there is a small issue with the logic. Let me explain.

Currently, the `is_cloudy` variable is being set to `False` for every report that is not cloudy. This means that if there is at least one report that is not cloudy, the `is_cloudy` variable will be set to `False` and the function will return `False`. However, we want the function to return `True` only if the rainiest report is also cloudy. To fix this, you can add a condition to check if the current report has more rainfall than the previous rainiest report before updating the `is_cloudy` variable.

I hope this helps! Let me know if you have any questions.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_structures_dataclasses_define_address\submissions\Aurorus_1.py
``````````````````````
from dataclasses import dataclass

@dataclass
class Address:
    number:int
    street:str
    city:str
    state:str
location=Address(18,"Amstel Ave","Newark","DE")
print(location)

``````````````````````
The code looks good and runs without any errors.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_structures_dataclasses_define_address\submissions\Krookodile_1.py
``````````````````````
from dataclasses import dataclass

@dataclass
class = Address
    number = int
    street = str
    city = str
    state = str

location = Address(18, "Amstel Ave", "Newark", "DE")
print(location.state)

``````````````````````
There is a syntax error in your code. The class definition should not have an equal sign after the 'class' keyword. Also, make sure to indent the attributes and methods inside the class.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_structures_dataclasses_define_address\submissions\Vanillish_1.py
``````````````````````
from dataclasses import dataclass

@dataclass
class Address:
    number: int
    street: str
    city: str
    state: str
    
location = Address(18,'Amstel Ave', 'Newark','DE')
print(location.state)

``````````````````````
The code looks good and will run without any errors.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_structures_dataclass_ops_merge_recipes\submissions\Cyndaquil_1.py
``````````````````````
from dataclasses import dataclass
from bakery import assert_equal

@dataclass
class Recipe:
    flour:int
    eggs:int
    milk:int
    sugar:int
    
def merg_recipes(rec:Recipe, rec2:Recipe) -> Recipe:
     rec = Recipe(1,3,2,2)
         rec2 = Recipe(3,4,2,4):
            return rec + rec2
``````````````````````
There are a few issues with your code:
1. You don't need to redefine `rec` and `rec2` inside the `merg_recipes` function.
2. You cannot use the `+` operator to combine two instances of the `Recipe` class. You need to manually add the corresponding attributes.
3. The return type of the `merg_recipes` function should be `Recipe`, not `None`.

Here's an updated version of your code:

```python
from dataclasses import dataclass

@dataclass
class Recipe:
    flour: int
    eggs: int
    milk: int
    sugar: int


def merge_recipes(rec: Recipe, rec2: Recipe) -> Recipe:
    return Recipe(rec.flour + rec2.flour, rec.eggs + rec2.eggs, rec.milk + rec2.milk, rec.sugar + rec2.sugar)


rec1 = Recipe(1, 3, 2, 2)
rec2 = Recipe(3, 4, 2, 4)
merged_recipe = merge_recipes(rec1, rec2)
print(merged_recipe)
```
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_structures_dataclass_ops_merge_recipes\submissions\Darumaka_1.py
``````````````````````
from dataclasses import dataclass
from bakery import assert_equal

@dataclass
class Recipe:
    flour: int
    eggs: int
    milk: int
    sugar: int

def merge_recipes (rec1:Recipe, rec2:Recipe)->Recipe:
    return rec1.flour + rec2.flour, rec1.eggs + rec2.eggs, rec1.milk + rec2.milk, rec1.suagr rec2.sugar

assert_equal(merge recipies(1,2,1,3,1,2,3,2), 3,4,3,5)
``````````````````````
There are a few issues with your code:
1. The function `merge_recipes` is missing a colon at the end of the function definition.
2. The return statement in `merge_recipes` is missing a comma between `rec1.suagr` and `rec2.sugar`.
3. The function call `merge recipies(1,2,1,3,1,2,3,2)` is missing a dot between `merge` and `recipies`.
4. The expected output in the `assert_equal` function is not wrapped in parentheses.
5. The expected output in the `assert_equal` function has a typo, it should be `3, 4, 3, 5` instead of `3,4,3,5`.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_structures_dataclass_ops_merge_recipes\submissions\Elgyem_1.py
``````````````````````
from dataclasses import dataclass
from bakery import assert_equal
@dataclass
class Recipe:
    flour: int
    eggs: int
    milk:int
    sugar:int
    
def merge_recipes(rec:Recipe,re:Recipe)->Recipe:
    new=Recipe(rec.flour+re.flour,rec.eggs+re.eggs,rec.milk+re.milk,rec.sugar+re.sugar)
    return new
rec= Recipe(1,2,2,3)
re= Recipe(2,2,2,3)
assert_equal(merge_recipes(rec,re),Recipe(3,4,4,6))
rec= Recipe(2,2,2,3)
re= Recipe(2,2,2,3)
assert_equal(merge_recipes(rec,re),Recipe(4,4,4,6))
``````````````````````
The code looks good and the assertions pass.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_structures_dataclass_ops_point_turtle\submissions\Anorith_1.py
``````````````````````
from dataclasses import dataclass
from bakery import assert_equal

@dataclass
class Turtle:
    speed: int
    direction: int

def point_turtle(turt: Turtle, direct: int) -> Turtle:
    turt.direction = direct
    return turt

assert_equal(point_turtle(Turtle(2, 1), 3), Turtle(2, 3))
assert_equal(point_turtle(Turtle(3, 1), 3), Turtle(3, 3))
assert_equal(point_turtle(Turtle(4, 1), 3), Turtle(4, 3))
``````````````````````
The code looks correct and the test cases pass.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_structures_dataclass_ops_point_turtle\submissions\Luxio_1.py
``````````````````````
from dataclasses import dataclass
from bakery import assert_equal

@dataclass
class Turtle:
    speed: int 
    direction: int

def point_turtle(ogTurtle: Turtle, newDirection: int):
    return Turtle(ogTurtle.speed, newDirection)

assert_equal(point_turtle(Turtle(10, 5), 10), Turtle(10, 10)
``````````````````````
You are missing a closing parenthesis at the end of the assert_equal statement.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_structures_dataclass_ops_point_turtle\submissions\Skuntank_1.py
``````````````````````
from dataclasses import dataclass
from bakery import assert_equal

@dataclass
class Turtle:
    speed: int
    direction: int
    
def point_turtle(t: Turtle, integer: int) -> Turtle:
    t.direction = integer
    return Turtle(t.speed, t.direction)

assert_equal(point_turtle(Turtle(10,20),10), Turtle(10,10))
assert_equal(point_turtle(Turtle(20,20),10), Turtle(20,10))
``````````````````````
The code looks correct and the assertions pass.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_structures_lists_code_book_list\submissions\Phanpy_1.py
``````````````````````
Mfb=["dark","shark","bee"]
print(Mfb)
``````````````````````
The code is correct. It will print the list Mfb.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_structures_lists_code_book_list\submissions\Riolu_1.py
``````````````````````
my_books = ["Harry Potter", "Percy Jackson", "The Prince of Mist"]
print(my_books)
``````````````````````
Great job! You have successfully created a list called 'my_books' and printed its contents.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_structures_lists_code_book_list\submissions\Torchic_1.py
``````````````````````

books = ["book1", "book2", "book3"]
print(books)
``````````````````````
The code looks fine. It will print the list of books.
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_structures_mutability_code_lower_rent\submissions\Carvanha_1.py
``````````````````````
def make_lower(upper_case:str) -> str:
    message = "THE RENT IS TOO HIGH!"
    lower_case = message.lower()
    return message

print(make_lower)
``````````````````````
The function make_lower is defined correctly. However, when calling the function, you should pass an argument inside the parentheses. For example, make_lower('THE RENT IS TOO HIGH!')
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_structures_mutability_code_lower_rent\submissions\Happiny_1.py
``````````````````````
message = "THE RENT IS TOO HIGH!"
message = message.lower()
print(message)
``````````````````````
Good job converting the message to lowercase!
-------------------------
C:\Users\John\Documents\pedal-kennel\examples\sigcse24\bakery_structures_mutability_code_lower_rent\submissions\Victreebel_1.py
``````````````````````
message = "THE RENT IS TOO HIGH!"
message = message.lower()
print(message)
``````````````````````
Good job converting the message to lowercase!
-------------------------
